# 4장, 처리율 제한 장치의 설계
네트워크 시스템에서 처리율 제한 장치(rate limiter)는 클라이언트 또는 서비스가 보내는 트래픽의 처리율(rate)을 제어하기 위한 장치다.


설계에 앞서, API에 처리율 제한 장치를 두면 좋은 점에 대해 알아보자.

* **DoS(Denial of Service) 공격에 의한 자원 고갈(resource starvation)을 방지**할 수 있다.
  * 대형 IT기업들이 공개한 거의 대부분의 API는 어떤 형태로든 처리율 제한 장치를 가지고 있다.
  * 예를 들어 트위터는 3시간 동안 300개의 트윗만 올릴 수 있도록 제한하고 있다.
  * 처리율 제한 장치는 추가 요청에 대해서는 처리를 중단함으로써 Dos 공격을 방지한다.
* **비용을 절감한다.**
  * 추가 요청에 대한 처리를 제한하면 서버를 많이 두지 않아도 되고, 우선순위가 높은 API에 더 많은 자원을 할당할 수 있다.
  * 아울러 처리율 제한은 제3자(third-party) API에 사용료를 지불하고 있는 회사들에게는 아주 중요한다.
  * 예를 들어 신용을 확인하거나, 신용카드 결제를 하거나, 건강 상태를 확인하는 등의 작업을 위해 호출하는 API에 대한 과금이 횟수에 따라 이루어진다면, 그 횟수를 제한할 수 있어야 비용을 절감할 수 있다.
* **서버 과부하를 막는다.**
  * 봇(bot)에서 오는 트래픽이나 사용자의 잘못된 이용 패턴으로 유발된 트래픽을 걸러내는데 처리율 제한 장치를 활용할 수 있다. 그리고 시스템 구축에 필요한 정보를 모으는 것이다.  

---

### 처리율 제한 장치를 어디에 둘 것인가? 
기본적인 클라이언트-서버 통신 모델을 사용할 때,
처리율 제한 장치는 클라이언트 측에 둘 수도 있고, 서버 측에 둘 수도 있다.

> **클라이언트 측에 둔다면**  
> 클라이언트 요청은 쉽게 위변조가 가능하기 때문에 일반적으로 클라이언트는 처리율 제한을 안정적으로 걸 수 있는 장소가 못 된다. 모든 클라이언트의 구현을 통제하는 것도 어려울 수 있다.
> 


> **서버 측에 둔다면**  
> 1. 처리율 제한 장치를 API 서버에 두는 방식 
>    ![](./img/4-1.png)
> 2. 처리율 제한 미들웨어를 만들어 해당 미들웨어로 하여금 API 서버로 가는 요청을 통제하도록 하는 방식 
>   ![](./img/4-2.png)
>

폭넓게 채택된 기술인 클라우드 마이크로 서비스의 경우, 처리율 제한 장치는 보통 API게이트웨이라 불리는 컴포넌트에 구현된다.  
API게이트웨이는 처리율제한, SSL 종단, 사용자인증, IP 허용목록 관리등을 지원하는 완전 위탁관리형 서비스, 즉 클라우드 업체가 유지보수를 담당하는 서비스다.  
일단 API게이트 웨이가 처리율 제한을 지원하는 미들웨어라는 점만 기억하도록 하자.

**처리율 제한 장치의 위치**는 처리율 제한 기능을 설계할 때 중요한 요소로, 처리율 제한 장치를 무조건 서버에 혹은 무조건 클라이언트에 두는 것이 정답은 아니다. 기술 스택이나 엔지니어링 인력, 우선순위, 목표에 따라 달라질 수 있다.

다만 일반적으로 적용될 수 있는 몇 가지 지침은 다음과 같다.

* 프로그래밍 언어, 캐시 서비스 등 현재 사용하고 있는 기술 스택을 고려하라. 현재 사용하는 프로그래밍 언어가 서버 측 구현을 지원하기 충분할 정도로 효율이 높은지 확인하라.
* 사업 필요에 맞는 처리율 제한 알고리즘을 찾아라. 서버 측에서 모든 것을 구현하기로 했다면, 알고리즘은 자유롭게 선택할 수 있다. 하지만 제3 사업자가 제공하는 게이트웨이를 사용하기로 했다면 선택지는 제한될 수 있다.
* 설계가 마이크로서비스에 기반하고 있고, 사용자 인증이나 IP 허용목록 관리 등을 처리하기 위해 API 게이트웨이를 이미 설계에 포함시켰다면 처리율 제한 기능 또한 게이트웨이에 포함시켜야 할 수도 있다.
* 처리율 제한 서비스를 직접 만드는 데는 시간이 든다. 처리율 제한 장치를 구현하기에 충분한 인력이 없다면 상용 API 게이트웨이를 쓰는 것이 바람직한 방법일 것이다.

---
###  처리율 제한 알고리즘
처리율 제한 알고리즘은 여러 가지인데, 각기 다른 장단점을 가지고 있다.
널리 알려진 알고리즘으로는 다음과 같다.

* [토큰 버킷(token bucket)](#토큰-버킷--token-bucket-)
* [누출 버킷(leaky bucket)](#누출-버킷--leaky-bucket-)
* [고정 윈도 카운터(fixed window counter)](#고정-윈도-카운터--fixed-window-counter-)
* [이동 윈도 로그(sliding window log)](#이동-윈도-로그--sliding-window-log-)
* [이동 윈도 카운터(sliding window counter)](#이동-윈도-카운터--sliding-window-counter-)

#### 토큰 버킷(token bucket)
토큰 버킷 알고리즘은 처리율 제한에 폭넓게 이용되고 있다.
간단하고, 알고리즘에 대한 세간의 이해도도 높은 편이며 인터넷 기업들이 보편적으로 사용하고 있다.  

**동작 방식**  
* 토큰 버킷은 지정된 용량을 갖는 컨테이너다. 이 버킷에는 사전에 설정된 양의 토큰이 주기적으로 채워진다. 토큰이 꽉 찬 버킷에는 더 이상의 토큰은 추가되지 않는다.
* 토큰 공급기(refiller)는 이 버킷에 매초 2개의 토큰을 추가한다. 버킷이 가득 차면 추가로 공급된 토큰은 버려진다.(overflow)
* 각 요청은 처리될 때마다 하나의 토큰을 사용한다. 요청이 도착하면 버킷에 충분한 토큰이 있는지 검사하게 된다.
  * 충분한 토큰이 있는 경우, 버킷에서 토큰 하나를 꺼낸 후 요청을 시스템에 전달한다.
  * 충분한 토큰이 없는 경우, 해당 요청은 버려진다.

✅특징
* 장점
  * 구현이 쉽다.
  * 메모리 사용 측면에서도 효율적이다.
  * 짧은 시간에 집중되는 트래픽도 처리 가능하다. 버킷에 남은 토큰이 있기만 하면 요청은 시스템에 전달될 것이다.
* 단점
  * 이 알고리즘은 버킷 크기와 토큰 공급률이라는 두 개의 인자를 가지고 있는데, 이 값을 적절하게 튜닝하는 것이 까다롭다.


#### 누출 버킷(leaky bucket)
토큰 버킷 알고리즘과 비슷하지만 요청 처리율이 고정되어 있다는 점이 다르다. 누출 버킷 알고리즘은 보통 FIFO 큐로 구현한다.  

**동작 방식**
* 요청이 도착하면 큐가 가득 차 있는지 본다. 빈 자리가 있는 경우에는 큐에 요청을 추가한다.
* 큐가 가득 차 있는 경우에는 새 요청은 버린다.
* 지정된 시간마다 큐에서 요청을 꺼내어 처리한다.  

✅ 특징
* 장점
  * 큐의 크기가 제한되어 있어 메모리 사용량 측면에서 효과적이다.
  * 고정된 처리율을 가지고 있기 때문에 안정적 출력(stable outflow rate)이 필요한 경우에 적합하다.
* 단점
  * 단시간에 많은 트래픽이 몰리는 경우 큐에는 오래된 요청들이 쌓이게 되고, 그 요청들을 제때 처리하지 못하면 최신 요청들을 버려지게 된다.
  * 두 개 인자를 올바르게 튜닝하기 까다로울 수 있다.


#### 고정 윈도 카운터(fixed window counter)
**동작 방식**  
타임라인을 고정된 간격의 윈도(window)로 나누고, 각 윈도마다 카운터를 붙인다.
요청이 접수될 때마다 이 카운터의 값은 1씩 증가한다.
이 카운터의 값이 사전에 설정된 임계치(threshold)에 도달하면 새로운 요청은 새 윈도가 열릴 때까지 버려진다.  

✅ 특징
* 장점
  * 메모리 효율이 좋다.
  * 이해하기 쉽다.
  * 윈도가 닫히는 시점에 카운터를 초기화하는 방식은 특정한 트래픽 패턴을 처리하기에 적합하다.
* 단점
  * 윈도 경계 부근에서 일시적으로 많은 트래픽이 몰려드는 경우, 기대했던 시스템의 처리 한도보다 많은 양의 요청을 처리하게 된다.
#### 이동 윈도 로그(sliding window log)
이동 윈도 로깅 알고리즘은 고정 윈도 카운터의 문제점(윈도 경계 부근에 트래픽이 집중되는 경우 시스템에 설정된 한도보다 많은 요청을 처리하게 되는 것)을 해결한다.  

**동작 방식**  
이 알고리즘은 요청의 타임스탬프(timestamp)를 추적한다. 타임스탬프 데이터는 보통 레디스(Redis)의 정렬 집합 같은 캐시에 보관한다.
새 요청이 오면 만료된 타임스탬프는 제거한다. 만료된 타임스탬프는 그 값이 현재 윈도의 시작 시점보다 오래된 타임스탬프를 말한다.
새 요청의 타임스탬프를 로그(log)에 추가한다.
로그의 크기가 허용치보다 같거나 작으면 요청을 시스템에 전달한다. 그렇지 않은 경우에는 처리를 거부한다.  

✅ 특징
* 장점
  * 어느 순간의 윈도를 보더라도, 허용되는 요청의 개수는 시스템의 처리율 한도를 넘지 않는다.
* 단점
  * 거부된 요청의 타임스탬프도 보관하기 때문에 다량의 메모리를 사용한다.
#### 이동 윈도 카운터(sliding window counter)

고정 윈도 카운터 알고리즘과 이동 윈도 로깅 알고리즘을 결합한 것이다.


* 장점
  * 이전 시간대의 평균 처리율에 따라 현재 윈도의 상태를 계산하므로 짧은 시간에 몰리는 트래픽에도 잘 대응한다.
  * 메모리 효율이 좋다.
* 단점
  * 직전 시간대에 도착한 요청이 균등하게 분포되어 있다고 가정한 상태에서 추정치를 계산하기 때문에 다소 느슨하다. (심각한 문제는 아니다.)
